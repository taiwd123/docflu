const fs = require('fs-extra');
const path = require('path');
const { execSync } = require('child_process');
const chalk = require('chalk');

class MermaidProcessor {
  constructor(confluenceClient, tempDir = '.docusaurus/temp') {
    this.confluenceClient = confluenceClient;
    this.tempDir = tempDir;
    this.processedDiagrams = new Map(); // Cache processed diagrams
    
    // Ensure temp directory exists
    fs.ensureDirSync(this.tempDir);
  }

  /**
   * Extract Mermaid diagrams from markdown content
   * @param {string} markdownContent - Raw markdown content
   * @returns {Array} - Array of mermaid diagram objects
   */
  extractMermaidDiagrams(markdownContent) {
    const diagrams = [];
    const mermaidRegex = /```mermaid\n([\s\S]*?)\n```/g;
    
    let match;
    while ((match = mermaidRegex.exec(markdownContent)) !== null) {
      const [fullMatch, diagramCode] = match;
      
      const diagram = {
        fullMatch,
        code: diagramCode.trim(),
        index: match.index,
        id: this.generateDiagramId(diagramCode)
      };

      diagrams.push(diagram);
    }

    return diagrams;
  }

  /**
   * Generate unique ID for diagram based on content
   */
  generateDiagramId(code) {
    const hash = require('crypto').createHash('md5').update(code).digest('hex');
    return `mermaid-${hash.substring(0, 8)}`;
  }

  /**
   * Check if Mermaid CLI is available
   */
  async checkMermaidCLI() {
    try {
      execSync('mmdc --version', { stdio: 'ignore' });
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Install Mermaid CLI if not available
   */
  async installMermaidCLI() {
    console.log(chalk.blue('üì¶ Installing Mermaid CLI...'));
    try {
      execSync('npm install -g @mermaid-js/mermaid-cli', { stdio: 'inherit' });
      console.log(chalk.green('‚úÖ Mermaid CLI installed successfully'));
      return true;
    } catch (error) {
      console.error(chalk.red('‚ùå Failed to install Mermaid CLI:', error.message));
      return false;
    }
  }

  /**
   * Generate image from Mermaid diagram code
   * @param {Object} diagram - Diagram object with code and id
   * @returns {string} - Path to generated image file
   */
  async generateDiagramImage(diagram) {
    const inputFile = path.join(this.tempDir, `${diagram.id}.mmd`);
    const outputFile = path.join(this.tempDir, `${diagram.id}.png`);

    try {
      // Write diagram code to temp file
      await fs.writeFile(inputFile, diagram.code, 'utf8');

      // Generate image using Mermaid CLI
      const command = `mmdc -i "${inputFile}" -o "${outputFile}" -t neutral -b white --width 800 --height 600`;
      execSync(command, { stdio: 'pipe' });

      // Check if output file was created
      if (await fs.pathExists(outputFile)) {
        console.log(chalk.green(`‚úÖ Generated diagram image: ${diagram.id}.png`));
        return outputFile;
      } else {
        throw new Error('Output file not created');
      }

    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è Failed to generate diagram ${diagram.id}: ${error.message}`));
      return null;
    } finally {
      // Clean up input file
      if (await fs.pathExists(inputFile)) {
        await fs.remove(inputFile);
      }
    }
  }

  /**
   * Upload diagram image to Confluence page
   * @param {string} pageId - Confluence page ID
   * @param {string} imagePath - Path to diagram image
   * @param {string} diagramId - Unique diagram ID
   * @returns {Object} - Attachment info
   */
  async uploadDiagramImage(pageId, imagePath, diagramId) {
    const fileName = `${diagramId}.png`;
    
    // Check if already uploaded
    const cacheKey = `${pageId}:${fileName}`;
    if (this.processedDiagrams.has(cacheKey)) {
      return this.processedDiagrams.get(cacheKey);
    }

    try {
      console.log(chalk.blue(`üì§ Uploading diagram: ${fileName}`));

      // Create form data for upload
      const FormData = require('form-data');
      const form = new FormData();
      form.append('file', fs.createReadStream(imagePath), {
        filename: fileName,
        contentType: 'image/png'
      });
      form.append('comment', `Mermaid diagram generated by DocuFlu CLI`);
      form.append('minorEdit', 'true');

      // Check if attachment already exists and delete it first
      try {
        const existingAttachments = await this.confluenceClient.api({
          method: 'GET',
          url: `/wiki/rest/api/content/${pageId}/child/attachment?filename=${fileName}`
        });

        if (existingAttachments.data.results.length > 0) {
          console.log(chalk.gray(`üîÑ Deleting existing attachment: ${fileName}`));
          const existingId = existingAttachments.data.results[0].id;
          await this.confluenceClient.api({
            method: 'DELETE',
            url: `/wiki/rest/api/content/${existingId}`
          });
        }
      } catch (error) {
        // Ignore errors when checking/deleting existing attachments
        console.log(chalk.gray(`Note: Could not check existing attachments: ${error.message}`));
      }

      // Upload to Confluence
      const response = await this.confluenceClient.api({
        method: 'POST',
        url: `/wiki/rest/api/content/${pageId}/child/attachment`,
        data: form,
        headers: {
          ...form.getHeaders(),
          'X-Atlassian-Token': 'no-check'
        },
        maxContentLength: Infinity,
        maxBodyLength: Infinity
      });

      const attachmentInfo = {
        id: response.data.results[0].id,
        title: response.data.results[0].title,
        downloadUrl: response.data.results[0]._links.download,
        webUrl: response.data.results[0]._links.webui
      };

      // Cache the result
      this.processedDiagrams.set(cacheKey, attachmentInfo);
      
      console.log(chalk.green(`‚úÖ Uploaded diagram: ${fileName}`));
      return attachmentInfo;

    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è Failed to upload diagram ${fileName}: ${error.message}`));
      if (error.response && error.response.data) {
        console.warn(chalk.gray(`API Error Details: ${JSON.stringify(error.response.data)}`));
      }
      return null;
    }
  }

  /**
   * Convert Mermaid code blocks to Confluence image format
   * @param {string} content - Markdown content with Mermaid blocks
   * @param {Map} diagramMap - Map of diagram ID -> attachment info
   * @returns {string} - Content with Confluence image references
   */
  convertMermaidToConfluenceFormat(content, diagramMap) {
    const mermaidRegex = /```mermaid\n([\s\S]*?)\n```/g;
    
    return content.replace(mermaidRegex, (match, diagramCode) => {
      const diagramId = this.generateDiagramId(diagramCode.trim());
      const attachment = diagramMap.get(diagramId);
      
      if (attachment) {
        // Convert to Confluence image format - match ImageProcessor format
        return `<ac:image>
          <ri:attachment ri:filename="${attachment.title}" />
        </ac:image>

<p><em>Mermaid Diagram</em></p>`;
      } else {
        // Fallback: show code block with warning
        console.warn(chalk.yellow(`‚ö†Ô∏è Diagram not processed: ${diagramId}`));
        return `<ac:structured-macro ac:name="code">
          <ac:parameter ac:name="language">mermaid</ac:parameter>
          <ac:plain-text-body><![CDATA[${diagramCode.trim()}]]></ac:plain-text-body>
        </ac:structured-macro>

<p><em>‚ö†Ô∏è Mermaid diagram could not be converted to image</em></p>`;
      }
    });
  }

  /**
   * Replace Mermaid code blocks in Confluence content (HTML/XML format)
   * @param {string} confluenceContent - Confluence Storage Format content
   * @param {Map} diagramMap - Map of diagram ID -> attachment info
   * @returns {string} - Content with Confluence image references
   */
     replaceMermaidInConfluenceContent(confluenceContent, diagramMap) {
     // Look for Confluence code blocks with mermaid language
     const mermaidCodeRegex = /<ac:structured-macro ac:name="code">\s*<ac:parameter ac:name="language">mermaid<\/ac:parameter>\s*<ac:plain-text-body><!\[CDATA\[([\s\S]*?)\]\]><\/ac:plain-text-body>\s*<\/ac:structured-macro>/g;
     
     return confluenceContent.replace(mermaidCodeRegex, (match, diagramCode) => {
       // Unescape HTML entities to match original markdown
       const unescapedCode = diagramCode
         .replace(/&gt;/g, '>')
         .replace(/&lt;/g, '<')
         .replace(/&amp;/g, '&')
         .replace(/&quot;/g, '"')
         .replace(/&#39;/g, "'");
       
       const cleanCode = unescapedCode.trim();
       const diagramId = this.generateDiagramId(cleanCode);
       const attachment = diagramMap.get(diagramId);
       
       if (attachment) {
         // Convert to Confluence image format
         return `<ac:image>
           <ri:attachment ri:filename="${attachment.title}" />
         </ac:image>

<p><em>Mermaid Diagram</em></p>`;
       } else {
         // Keep original code block with warning
         console.warn(chalk.yellow(`‚ö†Ô∏è Diagram not processed: ${diagramId}`));
         return `${match}

<p><em>‚ö†Ô∏è Mermaid diagram could not be converted to image</em></p>`;
       }
     });
   }

  /**
   * Process all Mermaid diagrams for a page
   * @param {string} pageId - Confluence page ID
   * @param {string} markdownContent - Original markdown content
   * @returns {Object} - {processedContent, stats}
   */
  async processMermaidDiagrams(pageId, markdownContent) {
    // Extract Mermaid diagrams
    const diagrams = this.extractMermaidDiagrams(markdownContent);
    
    if (diagrams.length === 0) {
      return {
        processedContent: markdownContent,
        stats: { total: 0, processed: 0, failed: 0 }
      };
    }

    console.log(chalk.blue(`üé® Found ${diagrams.length} Mermaid diagram(s) to process`));

    // Check if Mermaid CLI is available
    const hasMermaidCLI = await this.checkMermaidCLI();
    if (!hasMermaidCLI) {
      console.log(chalk.yellow('‚ö†Ô∏è Mermaid CLI not found. Attempting to install...'));
      const installed = await this.installMermaidCLI();
      if (!installed) {
        console.log(chalk.red('‚ùå Cannot process Mermaid diagrams without CLI. Skipping...'));
        return {
          processedContent: markdownContent,
          stats: { total: diagrams.length, processed: 0, failed: diagrams.length }
        };
      }
    }

    const diagramMap = new Map();
    let processedCount = 0;
    let failedCount = 0;

    // Process each diagram
    for (const diagram of diagrams) {
      try {
        // Generate image
        const imagePath = await this.generateDiagramImage(diagram);
        if (!imagePath) {
          failedCount++;
          continue;
        }

        // Upload to Confluence
        const attachmentInfo = await this.uploadDiagramImage(pageId, imagePath, diagram.id);
        if (attachmentInfo) {
          diagramMap.set(diagram.id, attachmentInfo);
          processedCount++;
        } else {
          failedCount++;
        }

        // Clean up temp image file
        if (await fs.pathExists(imagePath)) {
          await fs.remove(imagePath);
        }

      } catch (error) {
        console.warn(chalk.yellow(`‚ö†Ô∏è Error processing diagram ${diagram.id}: ${error.message}`));
        failedCount++;
      }
    }

    // Convert Mermaid blocks to Confluence format
    const processedContent = this.convertMermaidToConfluenceFormat(markdownContent, diagramMap);

    const stats = {
      total: diagrams.length,
      processed: processedCount,
      failed: failedCount
    };

    if (processedCount > 0) {
      console.log(chalk.green(`üé® Processed ${processedCount}/${diagrams.length} Mermaid diagrams`));
    }

    return { processedContent, stats, diagramMap };
  }

  /**
   * Clean up temp directory
   */
  async cleanup() {
    try {
      if (await fs.pathExists(this.tempDir)) {
        await fs.remove(this.tempDir);
        console.log(chalk.gray('üßπ Cleaned up temp directory'));
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è Failed to cleanup temp directory: ${error.message}`));
    }
  }
}

module.exports = MermaidProcessor; 